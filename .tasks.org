* Org mcp
  :PROPERTIES:
  :ID: 48524342
  :END:
** Headers
   :PROPERTIES:
   :ID: 28028254
   :END:
*** Modification
    :PROPERTIES:
    :ID: 92335292
    :END:
**** DONE change status by index [6/6]
     CLOSED: [2025-11-01 Sat 20:46]
     :PROPERTIES:
     :ID: 99590227
     :END:
     - [x] implement the modification as a method on the OrgFile type
     - [x] allow the tool call to generate the OrgFile from the input file
     - [x] return the modified headers as a list of rendered entries
     - [x] verify every status for this behaviour
     - [x] deduplicate headers in the response
     - [x] allow multiple indeces at once
*** Metadata
    :PROPERTIES:
    :ID: 32102203
    :END:
    - [x] parse the closed schedule tag
    - [x] parse the scheduled schedule tag
    - [x] parse the deadline schedule tag
    - [x] parse the date as an actual datetime
**** DONE parse properties
     :PROPERTIES:
     :ID: 82181185
     :END:
**** NEXT automatically set CLOSED tag
     :PROPERTIES:
     :ID: 14898686
     :END:
     - [x] Analyze the current structure and data model to identify where the CLOSED field fits.
       * The CLOSED tag in org mode is used to record the timestamp when a task is marked as DONE.
         In the org-mcp project, status transitions (such as from TODO/PROG to DONE)
         should trigger logic that sets the CLOSED property to the current timestamp.
         The data model already parses CLOSED tags,
         so the implementation should focus on updating the header's properties during status changes
         and ensuring this is reflected in both the in-memory structure and the persisted org file.
     - [ ] Identify where status transitions occur in the code (e.g., from TODO/PROG to DONE).
     - [ ] Implement logic during status transitions to set CLOSED to the current timestamp.
     - [ ] Write unit tests to validate that the CLOSED tag logic works properly.
     - [ ] Document implementation details and edge cases in project documentation.
**** TODO modification of properties
     :PROPERTIES:
     :ID: 55803461
     :END:
     - [ ] insert properties to the map
     - [ ] delete properties from the map
     - [ ] modify properties in the map
**** TODO modification of schedule tags
     :PROPERTIES:
     :ID: 88799343
     :END:
     - [ ] allow a schedule to be added to headers
     - [ ] allow modifying schedule date
     - [ ] CLOSED should always be automatic
**** TODO automatically set SCHEDULED tag
     :PROPERTIES:
     :ID: 24597521
     :END:
     - [ ] Create a function to automatically set the scheduled tag to today within the Golang code.
     - [ ] Write scheduled function implementation, capable of fetching current date and assigning it to schedule tag.
     - [ ] Ensure tests are written to validate scheduled tag is correctly set to today's date in different header states.
     - [ ] Convert the header status change logic to include scheduled tags by default.
     - [ ] Define test cases to validate that scheduled tags are set correctly for valid state transitions involving 'NEXT'.
     - [ ] Test the scenario where headers already contain a scheduled tag and ensure proper behavior when transitioning to NEXT.
*** Parsing
    :PROPERTIES:
    :ID: 87835160
    :END:
**** TODO add a constructor based solely from a PeekReader instance
     :PROPERTIES:
     :ID: 46024702
     :END:
*** Searching
    :PROPERTIES:
    :ID: 8406955
    :END:
**** TODO Fuzzy search implementation plan
     :PROPERTIES:
     :ID: 51483267
     :END:
     - [ ] Analyze requirements for fuzzy header/content search in org mode files (should the search match any header line, content, or both?).
     - [ ] Evaluate and choose a Go fuzzy matching library or method (e.g., github.com/lithammer/fuzzysearch, or custom scoring).
     - [ ] Design a RESTful API endpoint for fuzzy search (input fields: search string, optional filters like status/tags, limit, etc.; output: matched headers with score and context).
     - [ ] Implement search handler in mcp/server.go using the chosen algorithm on in-memory parsed org structure, scoring/returning best matches.
     - [ ] Add unit and integration tests for different types of queries, edge cases, and expected matches.
     - [ ] Document fuzzy search usage and add examples to API docs/test file.
**** DONE Vector search
     :PROPERTIES:
     :ID: 04236728
     :END:
*** TODO Consider SQLite for embedding storage enhancement
    :PROPERTIES:
    :ID: 37383517
    :END:
    - [ ] Analyze potential for a performance bottleneck in embedding generation for each vector search request.
**** TODO Current Issue
     :PROPERTIES:
     :ID: 23501976
     :END:
     - [ ] Vector search currently regenerates embeddings for every search request
     - [ ] Creates significant performance bottleneck, especially for large org files
     - [ ] Wastes API calls to embedding providers (OpenAI, etc.) or CPU cycles for local models
     - [ ] No persistence - embeddings lost on server restart
     - [ ] Regeneration time increases linearly with file size
**** TODO Benefits of SQLite Storage
     :PROPERTIES:
     :ID: 97146068
     :END:
     - [ ] Dramatically reduces search latency by caching embeddings instead of regenerating
     - [ ] Cost efficiency - reduces expensive API calls to embedding providers
     - [ ] Scalability - essential for large org files in knowledge management use cases
     - [ ] Persistence - embeddings survive server restarts
     - [ ] Go ecosystem fit - excellent SQLite libraries available (modernc.org/sqlite for pure Go, mattn/go-sqlite3 for C-based)
     - [ ] Incremental updates - only regenerate embeddings for modified headers
     - [ ] Advanced opportunity: Use sqlite-vss or sqlite-vec for native vector similarity search directly in database
**** TODO Implementation Strategy
     :PROPERTIES:
     :ID: 39886024
     :END:
***** Database Schema
      :PROPERTIES:
      :ID: 30138340
      :END:
      - [ ] Design embeddings table: (header_uid PRIMARY KEY, content_hash TEXT, embedding_blob BLOB, model_name TEXT, dimensions INTEGER, created_at TIMESTAMP, updated_at TIMESTAMP)
      - [ ] Add index on content_hash for fast lookups
      - [ ] Consider storing additional metadata (org file path, header title) for debugging
***** Cache Invalidation
      :PROPERTIES:
      :ID: 94949826
      :END:
      - [ ] Store SHA-256 hash of header content alongside embeddings
      - [ ] Compare content hash on each search to detect changes
      - [ ] Only regenerate embeddings for headers with changed content hash
      - [ ] Implement orphan cleanup to remove embeddings for deleted headers
***** Performance Optimization
      :PROPERTIES:
      :ID: 98802810
      :END:
      - [ ] Evaluate sqlite-vss extension for native vector similarity search
      - [ ] Evaluate sqlite-vec extension as alternative
      - [ ] Consider background worker for batch regeneration of stale embeddings
      - [ ] Implement connection pooling for concurrent access
***** Migration Path
      :PROPERTIES:
      :ID: 62771632
      :END:
      - [ ] Design backward-compatible initialization (create DB if not exists)
      - [ ] Add CLI flag to force regeneration of all embeddings
      - [ ] Support graceful fallback if database is corrupted
**** TODO Key Considerations
     :PROPERTIES:
     :ID: 47380298
     :END:
     - [ ] File size: Embeddings are large (~6KB per header for 1536 dimensions) but SQLite handles blobs well
     - [ ] Concurrency: SQLite's read concurrency is excellent; write locks shouldn't be an issue for read-heavy workload
     - [ ] Storage location: Store DB alongside org file or in XDG cache directory?
     - [ ] Schema versioning: Plan for future schema changes with version table
     - [ ] Orphan cleanup: Need strategy to detect and remove embeddings for deleted headers
     - [ ] Multiple org files: How to handle embeddings for multiple org files (one DB per file or unified DB)?
     - [ ] Error handling: What happens if embedding generation fails for some headers?
**** TODO Implementation Tasks
     :PROPERTIES:
     :ID: 55845642
     :END:
     - [ ] Research and choose SQLite library (modernc.org/sqlite vs mattn/go-sqlite3)
     - [ ] Research and evaluate vector extensions (sqlite-vss vs sqlite-vec)
     - [ ] Design database schema with proper indexes
     - [ ] Implement database initialization and migration logic
     - [ ] Create embedding storage layer with CRUD operations (Insert, Update, Get, Delete)
     - [ ] Implement content hashing for cache invalidation
     - [ ] Add cache invalidation logic in vector search handler
     - [ ] Add CLI flags for cache management (--clear-cache, --rebuild-cache, --cache-stats)
     - [ ] Write unit tests for storage layer (CRUD operations, concurrent access)
     - [ ] Write unit tests for cache hit/miss scenarios
     - [ ] Write integration tests for cache invalidation on content changes
     - [ ] Benchmark performance: compare cached vs non-cached search times
     - [ ] Document the caching strategy in README or docs/
     - [ ] Document maintenance procedures (cache clearing, troubleshooting)
** Bullets
   :PROPERTIES:
   :ID: 51396790
   :END:
*** DONE Bullet parsing
    :PROPERTIES:
    :ID: 83577245
    :END:
*** DONE Bullet modification [4/4]
    CLOSED: [2025-11-09 Sun 11:26]
    :PROPERTIES:
    :ID: 89764195
    :END:
**** DONE bullet creation
     CLOSED: [2025-11-08 Sat 17:06]
     :PROPERTIES:
     :ID: 82673695
     :END:
     - [x] Add support for omitting the index when creating a bullet. if no index is specified, append the bullet to the end rather than inserting at a specific position.
**** DONE bullet completion [9/9]
     :PROPERTIES:
     :ID: 62550511
     :END:
     - [x] Review both the bullet completion and manage bullet tools in main.go and document differences and overlap.
     - [x] Analyze interfaces and implementation of complete_checkbox and manage_bullet_point in main.go for overlap and differences.
     - [x] Design a unified tool input schema that supports bullet add, remove, and completion (toggle/complete) operations via a 'method' argument.
     - [x] Design a unified tool implementation, merging manage_bullet_point and complete_checkbox logic into a single handler with branching on method.
     - [x] Update error handling and shared routines to prevent code duplication and improve API consistency.
     - [x] Update and combine the tool documentation (InputSchema, description) to cover all operations.
     - [x] Update/extend all relevant unit tests, covering add, remove, and complete logic through the unified tool.
     - [x] Test the MCP integration to ensure the unified tool performs correctly end-to-end.
     - [x] Create a short report after implementation summarizing combined logic, new tool schema, example usage, and migration steps if needed.
**** DONE bullet deletion [4/4]
     DEADLINE: <2025-11-08 Sat>
     :PROPERTIES:
     :ID: 47234894
     :END:
     - [x] Implement bullet deletion function.
     - [x] Integrate bullet deletion in the bullet createion mcp tool.
     - [x] Write unit tests for bullet deletion.
     - [x] Test the MCP tool for correctness of execution and return values.
**** DONE synchornise header progress
     CLOSED: [2025-11-09 Sun 11:26]
     :PROPERTIES:
     :ID: 88266361
     :END:
     - [x] Parially done already with the =CheckProgress= function
       * Analyzed existing CheckProgress and header status logic.
         Confirmed CheckProgress sets header to DONE when progress is complete.
         Will update logic to set status to PROG if any checkbox is checked,
         and further synchronize with checkbox state.
         Planning to ensure thorough unit testing for any changes.
     - [x] Change header status automatically from =NEXT=/=TODO= to =PROG= if a single checkbox is set
     - [x] Change header status to =DONE= if =CheckProgress= has =Done()= as true.
     - [x] Unit test new functionality
*** PROG Bullet children [1/7]
    SCHEDULED: <2026-01-26 Mon> DEADLINE: <2026-02-02 Mon>
    :PROPERTIES:
    :ID: 90135268
    :END:
    - [x] Add a children field to the bullet struct
    - [ ] Assign a progress to a bullet point
    - [ ] Allow partially completed bullets =[-]=
    - [ ] Parse bullet children from the reader by peeking
    - [ ] Bullet points can have progress counters =[0/2]=
    - [ ] Children are always indented by 2 spaces
    - [ ] IDs should still be calculated by the index inside the header
** Plain content
   :PROPERTIES:
   :ID: 18319364
   :END:
*** DONE Plain text parsing [6/6]
    SCHEDULED: <2025-11-08 Sat> CLOSED: [2025-11-11 Tue 22:00]
    :PROPERTIES:
    :ID: 97732298
    :END:
    - [x] Extend the =ParseIndentedLine= function so it has a fallback to anything other than bullets etc.
    - [x] Add a =Text= type that implements =Render=
    - [x] Assign the default path of the switch case in =ParseIndentedLine= to a =Text= renderable.
    - [x] Unit test =Text= parsing
    - [x] Unit test rendering of =Text=
    - [x] Test the MCP integration by fetching a header and checking whether the plain text is returned as well.
*** TODO Plain text modification
    SCHEDULED: <2026-01-31 Sat> DEADLINE: <2026-02-02 Mon>
    :PROPERTIES:
    :ID: 73284623
    :END:
**** TODO add method
     :PROPERTIES:
     :ID: 46348459
     :END:
**** TODO modify method
     :PROPERTIES:
     :ID: 71553477
     :END:
**** TODO remove method
     :PROPERTIES:
     :ID: 71251836
     :END:
**** TODO testing
     :PROPERTIES:
     :ID: 13815625
     :END:
** Dates and schedules
   :PROPERTIES:
   :ID: 45374501
   :END:
*** PROG Date Parsing                                             :date:parsing:
    :PROPERTIES:
    :ID: 78268550
    :END:
    - [x] Analyze the org mode syntax for various date formats and ensure compliance with parsing standards.
    - [x] Develop a parser to read CLOSED and SCHEDULED timestamps, ensuring timezone support.
    - [ ] Write tests for parsing various edge cases, such as invalid or incomplete dates.
*** DONE Date Searching
    CLOSED: [2026-02-02 Mon 18:52]
    :PROPERTIES:
    :ID: 94835494
    :END:
    - [x] Implement exact match searching for SCHEDULED and DEADLINE tags.
    - [x] Implement range searching (Between A and B) for all timestamp types.
    - [x] Implement 'Overdue' logic: DEADLINE < Now AND Status != DONE.
    - [x] Add 'Completed' history search using the CLOSED timestamp.
    - [x] Support 'Missing' search to find tasks without assigned dates.
    - [x] Implement `DateFilter` struct inside `ViewItem` for localized date-based queries.
    - [x] Handle negative `Range` logic: Anchor date becomes the exclusive end-cap for past searches.
    - [x] Ensure date normalization (midnight-to-midnight) to prevent time-of-day filtering bugs.
    - [x] Add `ShowClosed` toggle to filter between active agenda and completion history.
*** TODO Schedule Modification
    :PROPERTIES:
    :ID: 22890236
    :END:
    - [ ] Support adding new schedules while validating for allowed date ranges.
    - [ ] Implement endpoint to modify dates (schedule adjustments) dynamically
** Markdown rendering
   :PROPERTIES:
   :ID: 48165813
   :END:
** AI Session Context & Tooling Progress :context:ai:session:
   :PROPERTIES:
   :ID: 96275729
   :END:
   * Optimized ~query_items~ tool with CSV output, deduplication, and document-order sorting.
   * Implemented ~PATH~ column using a UID-stack format (e.g., ~//ROOT/PARENT/ID~) for token-efficient navigation.
   * Added ~PREVIEW~ and ~TAGS~ (comma-quoted) columns to separate core text from Org-syntax noise.
   * Confirmed regex filtering on ~CONTENT~ matches against the ~PREVIEW~ text.
   * Verified that ~manage_header~ handles sequential updates and queries in a single multi-item request.
*** Data Formats & CSV Optimization
    :PROPERTIES:
    :ID: 32788174
    :END:
    * Primary tool output is standardized to CSV for maximum token efficiency.
    * Fields are automatically quoted (via ~encoding/csv~) to safely handle internal commas in content or tags.
    * ~PREVIEW~ column provides the 'clean' title/text, while ~CONTENT~ provides the raw Org-syntax for editing.
*** Query & Search Logic
    :PROPERTIES:
    :ID: 45715638
    :END:
    * Multi-item requests in ~manage_header~ and ~query_items~ are processed sequentially, allowing a single call to 'Update' then 'Get' a header state.
    * Global deduplication logic ensures unique UIDs in a single unified CSV response, even with overlapping depth/filter parameters.
    * Results are sorted by their original position in the document to preserve semantic flow.
*** Navigation & Hierarchical Context
    :PROPERTIES:
    :ID: 30640212
    :END:
    * The ~PATH~ column provides a token-efficient 'GPS' using UIDs (e.g., ~//ROOT/PARENT/ID~) to map hierarchy without repeating long titles.
    * Metadata columns like ~PARENT~ and ~CHILDREN_COUNT~ allow the model to navigate the tree structure without deep-reading content.
*** DONE Implemented CSV Columns [10/10]
    :PROPERTIES:
    :ID: 42321214
    :END:
    - [x] ~TYPE~: Go type of the renderable item (e.g., ~*orgmcp.Header~, ~*orgmcp.Bullet~).
    - [x] ~UID~: Unique identifier (string or integer) for the item.
    - [x] ~PREVIEW~: Clean text content without Org-mode syntax/markers. Best for token-efficient browsing.
    - [x] ~CONTENT~: Raw Org-mode content, including syntax and newlines (escaped as ~\n~).
    - [x] ~STATUS~: Header status (TODO, NEXT, PROG, DONE, etc.). Empty for bullets/text.
    - [x] ~PROGRESS~: Progress ratio (e.g., ~2/3~) for items with children/checkboxes.
    - [x] ~PARENT~: UID of the immediate parent item.
    - [x] ~CHILDREN_COUNT~: Number of direct children under the item.
    - [x] ~TAGS~: Comma-separated list of tags, quoted for CSV safety (e.g., ~"tag1,tag2"~).
    - [x] ~PATH~: Hierarchical stack of UIDs from root to item (e.g., ~//UID1/UID2/ID~).
*** Design Philosophy & Future Ideas
    :PROPERTIES:
    :ID: 74856328
    :END:
    * *AI-Native Goal*: Prioritize 'steering' data (UIDs, status, progress) over raw 'text' data to keep context windows small.
    * *CSV vs JSON*: CSV is preferred for bulk queries due to its higher data density and lower token overhead (no repeating keys).
    * *Document Order*: Always preserve file order in query results, as sequence is semantic in Org-mode. Avoid sorting by UIDs unless explicitly requested.
    * *Potential Column: STATUS_COUNTS*: Consider adding an aggregated view of children's statuses (e.g., TODO:3, DONE:5) to headers.
    * *Potential Column: LEVEL*: Adding numeric depth would allow models to reconstruct the tree structure without parsing Org stars.
    * *Dedicated Scheduling Columns*: Add ~DEADLINE~, ~SCHEDULED~, and ~CLOSED~ as dedicated CSV columns for high-performance date-based querying.
    * *Priority Support*: Support Org-mode priorities (e.g., ~[#A]~, ~[#B]~) as a standalone column.
    * *Body Preview Control*: Allow the ~PREVIEW~ or a new ~SUMMARY~ column to return a specific number of lines from the body text.
    * *Property Export*: A ~PROPERTIES~ column that returns all property drawer key-values as a parseable string.
    * *Date Range Filtering*: Add the ability to filter results by date ranges (e.g., ~SCHEDULED~ or ~DEADLINE~ between Date A and Date B) directly in ~query_items~.
** TODO Derive Tool Input Schema from Go Struct using Reflection :jsonrpc:schema:input:
   :PROPERTIES:
   :ID: 15951102
   :END:
   - [x] Use the `reflect` package to traverse Go struct fields and tags.
   - [x] Map Go types (string, int, bool, slices, etc.) to JSON Schema types.
   - [x] Extract descriptions, required status, and constraints from struct tags (e.g., `jsonschema:"description=..."`).
   - [x] Ensure nested structs are handled recursively to build complex input schemas.
   - [x] Support `json:",omitempty"` to distinguish between required and optional fields.
   - [x] Ensure `default` and `enum` values in the schema match the field's JSON type (e.g., numbers instead of strings for int fields).
   - [ ] Implement a registration helper in `mcp.Server` to simplify tool definition.
